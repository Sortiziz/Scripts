<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa de Rutas BGP</title>
    <script src="lib/cytoscape.min.js"></script>
    <script src="lib/jquery.min.js"></script>
    <script src="lib/popper.min.js"></script>
    <script src="lib/tippy-bundle.umd.min.js"></script>
    <link rel="stylesheet" href="lib/tippy.css"/>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #cy { width: 100%; height: 80vh; border: 1px solid #ccc; background-color: #fff; }
        #color-modal { width: 250px; border-radius: 8px; border: 1px solid #ccc; padding: 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 2000; position: absolute; background: white; display: none; transition: opacity 0.3s ease; }
        #color-modal.show { display: block; opacity: 1; }
        #color-modal input[type="color"] { vertical-align: middle; margin-right: 10px; }
        #color-modal button { margin-top: 10px; margin-right: 5px; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; background-color: #007bff; color: white; }
        #color-modal button:hover { background-color: #0056b3; }
        #popper-container { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1500; }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; color: #333; z-index: 1000; }
        #controls { margin-top: 10px; }
        #save-btn, #reset-positions-btn, #reset-colors-btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        #save-btn { background-color: #28a745; color: white; }
        #save-btn:hover { background-color: #218838; }
        #reset-positions-btn { background-color: #dc3545; color: white; }
        #reset-positions-btn:hover { background-color: #c82333; }
        #reset-colors-btn { background-color: #ffc107; color: black; }
        #reset-colors-btn:hover { background-color: #e0a800; }
    </style>
</head>
<body>
    <h1>Mapa de Rutas BGP</h1>
    <div id="cy"></div>
    <div id="controls">
        <label for="zoom-slider">Zoom: </label>
        <input type="range" id="zoom-slider" min="0.1" max="2" step="0.1" value="1">
        <button id="save-btn">Guardar</button>
        <button id="reset-positions-btn">Resetear Posiciones</button>
        <button id="reset-colors-btn">Resetear Colores</button>
    </div>
    <div id="color-modal">
        <h4>Selecciona el color para este elemento</h4>
        <label for="color-input">Color: </label>
        <input type="color" id="color-input">
        <br><br>
        <button id="apply-color-btn">Aplicar</button>
        <button id="cancel-color-btn">Cancelar</button>
    </div>
    <div id="popper-container"></div>
    <div id="loading" class="loading">Cargando mapa...</div>

    <script>
        const DEBUG = true;
        const log = (...args) => DEBUG && console.log(...args);
        let cy;

        // Utilidades
        const getRandomPosition = () => ({
            x: Math.floor(Math.random() * 800) + 100,
            y: Math.floor(Math.random() * 600) + 100,
        });

        const rgbToHex = (rgb) => {
            if (!rgb || typeof rgb !== "string") return "#ddd";
            const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!match) return "#ddd";
            const [_, r, g, b] = match;
            return `#${[r, g, b].map(x => parseInt(x).toString(16).padStart(2, "0")).join("")}`;
        };

        const getHostNumber = (ip) => {
            if (!ip || typeof ip !== "string") return "N/A";
            const parts = ip.split(".");
            return parts.length >= 4 ? parts[3].split("/")[0] : "N/A";
        };

        // Validación de datos
        const validateGraphData = (data) => {
            if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
                throw new Error("Formato de bgp_graph.json inválido");
            }
            const nodeIds = new Set(data.nodes.map(n => n.data.id));
            data.edges.forEach(edge => {
                const { source, target, sourceInterface, targetInterface } = edge.data;
                if (!nodeIds.has(source) || !nodeIds.has(target)) {
                    throw new Error(`Enlace inválido: ${source} o ${target} no existen`);
                }
                const sourceNode = data.nodes.find(n => n.data.id === source);
                const targetNode = data.nodes.find(n => n.data.id === target);
                if (sourceNode.data.interfaces && !sourceNode.data.interfaces[sourceInterface]) {
                    throw new Error(`Interfaz ${sourceInterface} no encontrada en ${source}`);
                }
                if (targetNode.data.interfaces && !targetNode.data.interfaces[targetInterface]) {
                    throw new Error(`Interfaz ${targetInterface} no encontrada en ${target}`);
                }
            });
            log("Datos validados:", { nodes: data.nodes.length, edges: data.edges.length });
            return true;
        };

        // Procesamiento de datos
        const generateInterfaceNodes = (nodes) => {
            const interfaceNodes = [];
            nodes.forEach(node => {
                if (node.data.interfaces) {
                    const routerId = node.data.id;
                    const parent = node.data.parent;
                    Object.entries(node.data.interfaces).forEach(([intfName, ip]) => {
                        const intfId = `${routerId}_${intfName}`;
                        interfaceNodes.push({
                            data: { id: intfId, label: intfName, type: "interface", router: routerId, ip, parent, color: "#FFA500" },
                            position: getRandomPosition(),
                        });
                    });
                }
            });
            return interfaceNodes;
        };

        const transformEdges = (edges, interfaceNodes) => {
            return edges.map(edge => {
                const { source, target, sourceInterface, targetInterface, weight } = edge.data;
                const sourceIntfId = `${source}_${sourceInterface}`;
                const targetIntfId = `${target}_${targetInterface}`;
                if (!interfaceNodes.some(n => n.data.id === sourceIntfId) || !interfaceNodes.some(n => n.data.id === targetIntfId)) {
                    log(`Advertencia: Interfaces ${sourceIntfId} o ${targetIntfId} no generadas`);
                    return null;
                }
                return { data: { source: sourceIntfId, target: targetIntfId, weight, color: "#000" } };
            }).filter(Boolean);
        };

        const addHierarchicalEdges = (nodes, edges) => {
            const hierarchicalEdges = [];
            nodes.forEach(node => {
                if (node.data.parent && !node.data.type) {
                    hierarchicalEdges.push({
                        data: { source: node.data.parent, target: node.data.id, type: "hierarchical", invisible: true },
                    });
                }
                if (node.data.type === "interface" && node.data.router) {
                    hierarchicalEdges.push({
                        data: { source: node.data.router, target: node.data.id, type: "router-interface", invisible: false },
                    });
                }
            });
            return edges.concat(hierarchicalEdges);
        };

        const loadData = (nodes) => {
            const savedData = JSON.parse(localStorage.getItem("bgpNodeData") || "{}");
            return nodes.map(node => {
                const nodeId = node.data.id;
                if (savedData.positions?.[nodeId]?.x && savedData.positions?.[nodeId]?.y) {
                    node.position = { x: savedData.positions[nodeId].x, y: savedData.positions[nodeId].y };
                } else {
                    node.position = getRandomPosition();
                }
                node.data.color = savedData.colors?.nodes?.[nodeId] || node.data.color || (node.data.type === "interface" ? "#FFA500" : node.data.parent ? "#00FF00" : "#ddd");
                return node;
            });
        };

        // Visualización
        const initializeGraph = async () => {
            const loadingElement = document.getElementById("loading");
            loadingElement.style.display = "block";
            try {
                const response = await fetch("bgp_graph.json");
                if (!response.ok) throw new Error(`Error al cargar bgp_graph.json: ${response.status}`);
                const data = await response.json();

                validateGraphData(data);
                const interfaceNodes = generateInterfaceNodes(data.nodes);
                const allNodes = loadData(data.nodes.concat(interfaceNodes));
                const transformedEdges = transformEdges(data.edges, interfaceNodes);
                const allEdges = addHierarchicalEdges(allNodes, transformedEdges);

                cy = cytoscape({
                    container: document.getElementById("cy"),
                    elements: { nodes: allNodes, edges: allEdges },
                    style: [
                        {
                            selector: "node[!parent]",
                            style: {
                                "background-color": ele => ele.data("color") || "#ddd",
                                shape: "rectangle",
                                label: "data(label)",
                                "text-valign": "top",
                                "text-halign": "center",
                                "font-size": 16,
                                padding: 20,
                                "border-width": 2,
                                "border-style": "dashed",
                            },
                        },
                        {
                            selector: "node[parent][!type]",
                            style: {
                                "background-color": ele => ele.data("color") || "#00FF00",
                                shape: "ellipse",
                                label: "data(label)",
                                width: 60,
                                height: 60,
                                "text-valign": "center",
                                "text-halign": "center",
                                "font-size": 14,
                                "border-width": 2,
                                "border-color": "#000",
                            },
                        },
                        {
                            selector: "node[type='interface']",
                            style: {
                                "background-color": ele => ele.data("color") || "#FFA500",
                                shape: "ellipse",
                                label: "data(label)",
                                width: 40,
                                height: 40,
                                "text-valign": "center",
                                "text-halign": "center",
                                "font-size": 12,
                                "border-width": 1,
                                "border-color": "#000",
                            },
                        },
                        {
                            selector: "edge[type='hierarchical']",
                            style: { "line-color": "#000", opacity: 0 },
                        },
                        {
                            selector: "edge[type='router-interface']",
                            style: { 
                                "line-color": "#000", 
                                width: 1, 
                                opacity: 0.2, 
                                "curve-style": "bezier",
                                label: "", 
                                "source-label": "", 
                                "target-label": "" 
                            },
                        },
                        {
                            selector: "edge[!invisible][type!='hierarchical'][type!='router-interface']",
                            style: {
                                "line-color": ele => ele.data("color") || "#000",
                                width: 3,
                                label: "data(weight)",
                                "font-size": 14,
                                "text-background-color": "#FFFFFF",
                                "text-background-opacity": 0.9,
                                "text-background-padding": 3,
                                "source-label": "",
                                "target-label": "",
                                "source-text-offset": 30,
                                "target-text-offset": 30,
                                "source-text-margin-y": -10,
                                "target-text-margin-y": -10,
                                "text-rotation": "autorotate",
                                "curve-style": "bezier",
                            },
                        },
                    ],
                    layout: {
                        name: "preset",
                        positions: allNodes.reduce((acc, node) => {
                            acc[node.data.id] = node.position;
                            return acc;
                        }, {}),
                        fit: true,
                        padding: 30,
                    },
                });

                updateEdgeLabels(cy);
                setupInteractivity(cy);
                return cy;
            } catch (error) {
                console.error("Error al inicializar el grafo:", error);
                loadingElement.textContent = `Error: ${error.message}. Intenta recargar.`;
                throw error;
            } finally {
                setTimeout(() => (loadingElement.style.display = "none"), 3000);
            }
        };

        // Actualizar etiquetas solo para enlaces entre interfaces
        const updateEdgeLabels = (cy) => {
            cy.edges("[!invisible][type!='hierarchical'][type!='router-interface']").forEach(edge => {
                const sourceIp = cy.getElementById(edge.data("source")).data("ip") || "N/A";
                const targetIp = cy.getElementById(edge.data("target")).data("ip") || "N/A";
                edge.style({
                    "source-label": `.${getHostNumber(sourceIp)}`,
                    "target-label": `.${getHostNumber(targetIp)}`,
                    "font-size": 12,
                    "color": "#00008B",
                    "text-background-color": "#FFFFFF",
                    "text-background-opacity": 0.9,
                    "text-background-padding": 3,
                });
            });
        };

        // Interactividad
        const setupInteractivity = (cy) => {
            const edgeLabelStates = new Map();
            const toggleEdgeLabel = (edge) => {
                const edgeId = edge.id();
                const state = edgeLabelStates.get(edgeId) === "full" ? "host" : "full";
                edgeLabelStates.set(edgeId, state);
                const sourceIp = cy.getElementById(edge.data("source")).data("ip") || "N/A";
                const targetIp = cy.getElementById(edge.data("target")).data("ip") || "N/A";
                edge.style({
                    "source-label": state === "host" ? `.${getHostNumber(sourceIp)}` : sourceIp,
                    "target-label": state === "host" ? `.${getHostNumber(targetIp)}` : targetIp,
                });
            };

            cy.edges("[!invisible][type!='hierarchical'][type!='router-interface']").on("click", evt => toggleEdgeLabel(evt.target));

            const modal = document.getElementById("color-modal");
            const applyColorBtn = document.getElementById("apply-color-btn");
            const cancelColorBtn = document.getElementById("cancel-color-btn");
            let selectedElementId = null;

            cy.on("dblclick", "node, edge[!invisible][type!='hierarchical']", evt => {
                const element = evt.target;
                const pos = element.isNode() ? element.renderedPosition() : element.renderedMidpoint();
                const modalWidth = 250, modalHeight = 180;
                const left = Math.max(0, Math.min(pos.x, cy.width() - modalWidth));
                const top = Math.max(0, Math.min(pos.y, cy.height() - modalHeight));

                modal.style.left = `${left}px`;
                modal.style.top = `${top}px`;
                modal.style.display = "block";
                modal.classList.add("show");

                selectedElementId = element.id();
                const currentColor = element.isNode() ? element.style("background-color") : element.style("line-color");
                document.getElementById("color-input").value = rgbToHex(currentColor);
            });

            applyColorBtn.addEventListener("click", () => {
                if (selectedElementId) {
                    const element = cy.getElementById(selectedElementId);
                    const newColor = document.getElementById("color-input").value;
                    if (element.isNode()) element.style("background-color", newColor);
                    else element.style("line-color", newColor);
                    element.data("color", newColor);
                    modal.classList.remove("show");
                    setTimeout(() => (modal.style.display = "none"), 300);
                    selectedElementId = null;
                }
            });

            cancelColorBtn.addEventListener("click", () => {
                modal.classList.remove("show");
                setTimeout(() => (modal.style.display = "none"), 300);
                selectedElementId = null;
            });

            const popperContainer = document.getElementById("popper-container");
            const setupTooltips = () => {
                popperContainer.innerHTML = "";
                cy.nodes().forEach(node => {
                    const div = document.createElement("div");
                    div.style.position = "absolute";
                    popperContainer.appendChild(div);
                    const tip = tippy(div, {
                        content: node.data("type") === "interface"
                            ? `Interfaz: ${node.data("label")}<br>Router: ${node.data("router")}<br>IP: ${node.data("ip")}`
                            : `ID: ${node.id()}<br>AS: ${node.data("parent") || "N/A"}`,
                        theme: "light",
                        placement: "top",
                        trigger: "manual",
                    });
                    node.on("mouseover", () => tip.show()).on("mouseout", () => tip.hide());
                });
            };
            setupTooltips();

            const saveData = () => {
                const positions = {};
                const colors = { nodes: {}, edges: {} };
                cy.nodes().forEach(node => {
                    positions[node.id()] = node.position();
                    colors.nodes[node.id()] = rgbToHex(node.style("background-color"));
                });
                cy.edges("[!invisible][type!='hierarchical']").forEach(edge => {
                    colors.edges[edge.id()] = rgbToHex(edge.style("line-color"));
                });
                localStorage.setItem("bgpNodeData", JSON.stringify({ positions, colors }));
                alert("Datos guardados correctamente.");
            };

            const resetPositions = () => {
                cy.layout({
                    name: "cose",
                    fit: true,
                    padding: 30,
                    animate: true,
                    idealEdgeLength: edge => {
                        if (edge.data("type") === "router-interface") return 20; // Corta para router-interfaz
                        if (edge.data("weight")) return 200; // Larga para enlaces entre interfaces
                        return 100; // Default para otros (e.g., AS a router)
                    },
                    nodeRepulsion: 200000,
                    edgeElasticity: 50,
                }).run();
            };

            const resetColors = () => {
                cy.batch(() => {
                    cy.nodes("[!parent]").style("background-color", "#ddd");
                    cy.nodes("[parent][!type]").style("background-color", "#00FF00");
                    cy.nodes("[type='interface']").style("background-color", "#FFA500");
                    cy.edges("[!invisible][type!='hierarchical']").style("line-color", "#000");
                });
                updateEdgeLabels(cy);
            };

            document.getElementById("save-btn").addEventListener("click", saveData);
            document.getElementById("reset-positions-btn").addEventListener("click", resetPositions);
            document.getElementById("reset-colors-btn").addEventListener("click", resetColors);
            document.getElementById("zoom-slider").addEventListener("input", () => cy.zoom(parseFloat(event.target.value)));
        };

        // Iniciar aplicación
        initializeGraph().then(() => log("Grafo listo")).catch(() => log("Inicialización fallida"));
    </script>
</body>
</html>