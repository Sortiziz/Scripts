<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa de Rutas BGP</title>
    <!-- Bibliotecas locales -->
    <script src="lib/cytoscape.min.js"></script>
    <script src="lib/jquery.min.js"></script>
    <script src="lib/popper.min.js"></script>
    <script src="lib/tippy-bundle.umd.min.js"></script>
    <link rel="stylesheet" href="lib/tippy.css"/>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            position: relative; /* Asegurar que el cuerpo sea el contenedor raíz para z-index */
        }
        #cy {
            width: 100%;
            height: 80vh;
            border: 1px solid #ccc;
            background-color: #fff;
            position: relative; /* Asegurar que Cytoscape no interfiera con el z-index */
        }
        #color-modal {
            width: 250px;
            border-radius: 8px;
            border: 1px solid #ccc;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 2000; /* Aumentar el z-index para priorizar sobre otros elementos */
            position: absolute;
            background: white;
            display: none;
            transition: opacity 0.3s ease;
            opacity: 0;
        }
        #color-modal.show {
            display: block !important; /* Forzar display block para evitar conflictos */
            opacity: 1 !important; /* Forzar opacidad para asegurar visibilidad */
        }
        #color-modal input[type="color"] {
            vertical-align: middle;
            margin-right: 10px;
        }
        #color-modal button {
            margin-top: 10px;
            margin-right: 5px;
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
        }
        #color-modal button:hover {
            background-color: #0056b3;
        }
        #popper-container {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1500; /* Asegurar que esté por debajo del modal pero por encima de Cytoscape */
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #333;
            z-index: 1000; /* Asegurar que esté visible sobre todo */
        }
        #controls {
            margin-top: 10px;
            z-index: 1100; /* Asegurar que los controles estén visibles */
        }
        #save-positions-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            margin-right: 10px;
        }
        #save-positions-btn:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>
    <h1>Mapa de Rutas BGP</h1>
    <div id="cy"></div>
    <div id="controls">
        <label for="zoom-slider">Zoom: </label>
        <input type="range" id="zoom-slider" min="0.1" max="2" step="0.1" value="1">
        <button id="save-positions-btn">Guardar Posiciones</button>
    </div>
    
    <div id="color-modal">
        <h4>Selecciona el color para este AS</h4>
        <label for="color-input">Color: </label>
        <input type="color" id="color-input">
        <br><br>
        <button onclick="applyColor()">Aplicar</button>
        <button onclick="hideColorModal()">Cancelar</button>
    </div>

    <div id="popper-container"></div>
    <div id="loading" class="loading">Cargando mapa...</div>

    <script>
        let cy;
        let selectedAs = null;
        let edgeLabelStates = new Map(); // Mapa para rastrear el estado de las etiquetas (host o IP completa)
        let isModalClosing = false; // Flag para evitar conflictos de timing con el modal

        // Mostrar mensaje de carga
        document.getElementById('loading').style.display = 'block';

        // Función para validar datos
        function validateGraphData(data) {
            if (!data || !Array.isArray(data.nodes) || !Array.isArray(data.edges)) {
                throw new Error('Formato de bgp_graph.json inválido');
            }
            data.nodes.forEach(node => {
                if (node.data.parent && !node.data.interfaces) {
                    console.warn(`Nodo ${node.data.id} tiene parent pero no interfaces`);
                }
            });
            return true;
        }

        // Función para guardar posiciones manualmente en localStorage
        function savePositionsManually() {
            const positions = {};
            cy.nodes().forEach(node => {
                positions[node.id()] = node.position();
                console.log(`Guardando posición para nodo ${node.id()}:`, node.position(), 'Datos del nodo:', node.data());
            });
            localStorage.setItem('bgpNodePositions', JSON.stringify(positions));
            alert('Posiciones guardadas correctamente.');
            console.log("Posiciones guardadas:", positions);
        }

        // Función para cargar posiciones desde localStorage y preparar nodos con posiciones
        function loadPositions(nodesData) {
            const savedPositions = localStorage.getItem('bgpNodePositions');
            console.log("Posiciones guardadas en localStorage:", savedPositions);
            if (savedPositions) {
                const positions = JSON.parse(savedPositions);
                console.log("Posiciones parseadas:", positions);
                return nodesData.map(node => {
                    console.log(`Verificando posición para nodo ${node.data.id}, datos actuales:`, node.data);
                    if (positions[node.data.id]) {
                        console.log(`Aplicando posición a nodo ${node.data.id}:`, positions[node.data.id], 'Datos antes de aplicar posición:', node.data);
                        return { ...node, position: positions[node.data.id] };
                    }
                    console.log(`No se encontró posición guardada para nodo ${node.data.id}, datos actuales:`, node.data);
                    return node;
                });
            }
            console.log("No hay posiciones guardadas en localStorage");
            return nodesData;
        }

        // Función para extraer el número del host (último octeto) de una IP
        function getHostNumber(ip) {
            if (!ip || typeof ip !== 'string') return 'N/A';
            const parts = ip.split('.');
            if (parts.length >= 4) {
                return parts[3].split('/')[0]; // Extrae solo el último octeto antes de "/"
            }
            return 'N/A';
        }

        // Función para convertir RGB a hexadecimal
        function rgbToHex(rgb) {
            if (!rgb || typeof rgb !== 'string') return '#DDDDDD'; // Valor por defecto si no hay color
            const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            if (!match) return '#DDDDDD'; // Valor por defecto si el formato no es válido
            const [_, r, g, b] = match;
            return `#${[r, g, b].map(x => parseInt(x).toString(16).padStart(2, '0')).join('')}`;
        }

        // Función para alternar entre mostrar el número del host y la IP completa
        function toggleEdgeLabel(edge) {
            const edgeId = edge.id();
            if (!edgeLabelStates.has(edgeId)) {
                edgeLabelStates.set(edgeId, 'host'); // Estado inicial: mostrar solo el host
            }

            const currentState = edgeLabelStates.get(edgeId);
            let newLabel;

            if (currentState === 'host') {
                // Mostrar IP completa
                const sourceNode = edge.source();
                const targetNode = edge.target();
                const sourceIp = sourceNode.data('ip') || 'N/A';
                const targetIp = targetNode.data('ip') || 'N/A';
                newLabel = {
                    'source-label': sourceIp,
                    'target-label': targetIp
                };
                edgeLabelStates.set(edgeId, 'full');
                console.log(`Mostrando IP completa para enlace ${edgeId}:`, newLabel);
            } else {
                // Mostrar número del host con punto
                const sourceNode = edge.source();
                const targetNode = edge.target();
                const sourceIp = sourceNode.data('ip') || 'N/A';
                const targetIp = targetNode.data('ip') || 'N/A';
                const sourceHost = getHostNumber(sourceIp);
                const targetHost = getHostNumber(targetIp);
                newLabel = {
                    'source-label': sourceHost ? `.${sourceHost}` : 'Sin IP',
                    'target-label': targetHost ? `.${targetHost}` : 'Sin IP'
                };
                edgeLabelStates.set(edgeId, 'host');
                console.log(`Mostrando número del host para enlace ${edgeId}:`, newLabel);
            }

            edge.style(newLabel);
        }

        fetch('bgp_graph.json')
            .then(response => {
                if (!response.ok) throw new Error(`No se pudo cargar bgp_graph.json: ${response.status}`);
                return response.json();
            })
            .then(data => {
                try {
                    validateGraphData(data);

                    // Depuración: Mostrar datos originales del JSON
                    console.log("Datos originales del JSON:", data);

                    // Generar nodos de interfaz dinámicamente con IDs únicos
                    const interfaceNodes = [];
                    const interfaceEdges = [];
                    data.nodes.forEach(node => {
                        if (node.data.interfaces) {
                            const routerId = node.data.id;
                            const parent = node.data.parent;
                            console.log(`Procesando nodo router: ${routerId}, interfaces:`, node.data.interfaces);
                            Object.entries(node.data.interfaces).forEach(([intfName, ip]) => {
                                const intfId = `${routerId}_${intfName}`; // Usar formato único: router_interfaz (e.g., "R2_eth0")
                                console.log(`Generando nodo de interfaz: ${intfId}, IP: ${ip}`);
                                interfaceNodes.push({
                                    data: {
                                        id: intfId,
                                        label: intfName, // Mantén el nombre original para la visualización (e.g., "eth0")
                                        type: 'interface',
                                        router: routerId,
                                        ip: ip, // Asegurarse de que el campo 'ip' esté explícitamente asignado
                                        parent: parent
                                    }
                                });
                                interfaceEdges.push({
                                    data: {
                                        source: routerId,
                                        target: intfId,
                                        invisible: true
                                    }
                                });
                            });
                        }
                    });

                    // Depuración: Mostrar nodos de interfaz generados con sus datos completos
                    console.log("Nodos de interfaz generados:", interfaceNodes.map(n => ({ id: n.data.id, ip: n.data.ip, label: n.data.label })));

                    // Transformar enlaces de routers a interfaces con IDs únicos
                    const transformedEdges = data.edges.map(edge => {
                        const sourceRouter = edge.data.source;
                        const targetRouter = edge.data.target;
                        const sourceInterface = edge.data.sourceInterface;
                        const targetInterface = edge.data.targetInterface;
                        const weight = edge.data.weight;

                        // Depuración
                        console.log(`Transformando enlace: ${sourceRouter} (${sourceInterface}) -> ${targetRouter} (${targetInterface})`);

                        // Verificar que las interfaces existan en los nodos generados
                        const sourceIntfId = `${sourceRouter}_${sourceInterface}`; // Usar formato único (e.g., "R2_eth0")
                        const targetIntfId = `${targetRouter}_${targetInterface}`; // Usar formato único (e.g., "R3_eth0")

                        // Verificar que las interfaces existan antes de crear el enlace
                        let sourceNodeExists = interfaceNodes.some(n => n.data.id === sourceIntfId && n.data.router === sourceRouter);
                        let targetNodeExists = interfaceNodes.some(n => n.data.id === targetIntfId && n.data.router === targetRouter);

                        // Depuración: Verificar existencia de nodos y sus IPs
                        const sourceNode = interfaceNodes.find(n => n.data.id === sourceIntfId);
                        const targetNode = interfaceNodes.find(n => n.data.id === targetIntfId);
                        console.log(`Nodo fuente ${sourceIntfId} existe: ${sourceNodeExists}, IP: ${sourceNode ? sourceNode.data.ip : 'No encontrado'}`);
                        console.log(`Nodo destino ${targetIntfId} existe: ${targetNodeExists}, IP: ${targetNode ? targetNode.data.ip : 'No encontrado'}`);

                        // Generar dinámicamente nodos de interfaz faltantes
                        if (!sourceNodeExists) {
                            const ip = data.nodes.find(n => n.data.id === sourceRouter)?.data.interfaces?.[sourceInterface];
                            if (ip) {
                                console.log(`Interfaz no encontrada: source=${sourceIntfId} (router=${sourceRouter}), generando dinámicamente...`);
                                interfaceNodes.push({
                                    data: {
                                        id: sourceIntfId,
                                        label: sourceInterface,
                                        type: 'interface',
                                        router: sourceRouter,
                                        ip: ip,
                                        parent: data.nodes.find(n => n.data.id === sourceRouter)?.data.parent
                                    }
                                });
                                interfaceEdges.push({
                                    data: {
                                        source: sourceRouter,
                                        target: sourceIntfId,
                                        invisible: true
                                    }
                                });
                                sourceNodeExists = true;
                                console.log(`Nodo de interfaz generado dinámicamente: ${sourceIntfId} (router=${sourceRouter}, ip=${ip})`);
                            }
                        }
                        if (!targetNodeExists) {
                            const ip = data.nodes.find(n => n.data.id === targetRouter)?.data.interfaces?.[targetInterface];
                            if (ip) {
                                console.log(`Interfaz no encontrada: target=${targetIntfId} (router=${targetRouter}), generando dinámicamente...`);
                                interfaceNodes.push({
                                    data: {
                                        id: targetIntfId,
                                        label: targetInterface,
                                        type: 'interface',
                                        router: targetRouter,
                                        ip: ip,
                                        parent: data.nodes.find(n => n.data.id === targetRouter)?.data.parent
                                    }
                                });
                                interfaceEdges.push({
                                    data: {
                                        source: targetRouter,
                                        target: targetIntfId,
                                        invisible: true
                                    }
                                });
                                targetNodeExists = true;
                                console.log(`Nodo de interfaz generado dinámicamente: ${targetIntfId} (router=${targetRouter}, ip=${ip})`);
                            }
                        }

                        return {
                            data: {
                                source: sourceIntfId,
                                target: targetIntfId,
                                weight: weight
                            }
                        };
                    }).filter(edge => edge !== null); // Filtrar enlaces nulos

                    // Depuración: Mostrar enlaces transformados
                    console.log("Enlaces transformados:", transformedEdges);

                    // Combinar nodos y enlaces originales con los generados
                    const allNodes = data.nodes.concat(interfaceNodes);
                    const allEdges = interfaceEdges.concat(transformedEdges);

                    // Depuración: Mostrar todos los nodos combinados con sus IPs
                    console.log("Todos los nodos combinados:", allNodes.map(n => ({ id: n.data.id, ip: n.data.ip, label: n.data.label, type: n.data.type })));
                    console.log("Todos los enlaces combinados:", allEdges);

                    // Cargar posiciones guardadas y aplicarlas a los nodos antes de inicializar Cytoscape
                    const nodesWithPositions = loadPositions(allNodes);

                    // Depuración: Mostrar nodos con posiciones y verificar IPs después de cargar posiciones
                    console.log("Nodos con posiciones aplicadas:", nodesWithPositions.map(n => ({ id: n.data.id, ip: n.data.ip, label: n.data.label, type: n.data.type, position: n.position })));

                    cy = cytoscape({
                        container: document.getElementById('cy'),
                        elements: { nodes: nodesWithPositions, edges: allEdges },
                        style: [
                            {
                                selector: 'node[parent][!type]', // Routers dentro de AS
                                style: {
                                    'background-color': '#00FF00',
                                    'shape': 'ellipse',
                                    'width': 60,
                                    'height': 60,
                                    'label': 'data(label)',
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'font-size': 14,
                                    'color': '#000',
                                    'border-width': 2,
                                    'border-color': '#000',
                                    'z-index': 5
                                }
                            },
                            {
                                selector: 'node[!parent]', // AS
                                style: {
                                    'shape': 'rectangle',
                                    'background-color': '#ddd',
                                    'padding': 20,
                                    'label': 'data(label)',
                                    'font-size': 16,
                                    'text-valign': 'top',
                                    'text-halign': 'center',
                                    'text-margin-y': -10,
                                    'border-width': 2,
                                    'border-color': '#000',
                                    'border-style': 'dashed',
                                    'z-index': 1
                                }
                            },
                            {
                                selector: 'node[type="interface"]', // Interfaces
                                style: {
                                    'background-color': '#FFA500',
                                    'shape': 'ellipse',
                                    'width': 40,
                                    'height': 40,
                                    'label': 'data(label)', // Mostrar el nombre original (e.g., "eth0")
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'font-size': 12,
                                    'color': '#000',
                                    'border-width': 1,
                                    'border-color': '#000',
                                    'z-index': 10
                                }
                            },
                            {
                                selector: 'edge[!invisible]', // Solo enlaces visibles (con weight)
                                style: {
                                    'width': 3,
                                    'line-color': '#000',
                                    'curve-style': 'bezier',
                                    'label': 'data(weight)', // Subred en el centro
                                    'font-size': 14,
                                    'color': '#00008B',
                                    'text-background-color': '#FFFFFF',
                                    'text-background-opacity': 0.9,
                                    'text-background-padding': 3,
                                    'source-label': ele => {
                                        // Depuración: Mostrar datos del elemento y su nodo fuente
                                        console.log(`Evaluando source-label para enlace: ${JSON.stringify(ele.data())}`);
                                        const sourceId = ele.data('source');
                                        if (cy && cy.getElementById) { // Verificar que cy está inicializado
                                            const sourceNode = cy.getElementById(sourceId);
                                            console.log(`Nodo fuente ${sourceId}:`, sourceNode.data());
                                            if (sourceNode.length > 0) {
                                                const sourceIp = sourceNode.data('ip');
                                                console.log(`IP del nodo fuente ${sourceId}: ${sourceIp} (tipo: ${typeof sourceIp}, nodo: ${sourceNode.id()})`);
                                                if (sourceIp && sourceIp !== '') { // Verificar si sourceIp existe y no está vacío
                                                    return `.${getHostNumber(sourceIp)}`; // Mostrar solo el número del host con un punto delante
                                                } else {
                                                    // Intentar recuperar desde router sin warnings
                                                    const routerId = sourceNode.data('router');
                                                    if (routerId) {
                                                        const routerNode = cy.getElementById(routerId);
                                                        const routerInterfaces = routerNode ? routerNode.data('interfaces') : null;
                                                        if (routerInterfaces) {
                                                            const interfaceName = sourceId.split('_')[1]; // Extraer el nombre de la interfaz (e.g., "eth0")
                                                            const ipFromRouter = routerInterfaces[interfaceName];
                                                            console.log(`IP encontrada en router para interfaz ${interfaceName}: ${ipFromRouter}`);
                                                            if (ipFromRouter && ipFromRouter !== '') {
                                                                return `.${getHostNumber(ipFromRouter)}`; // Mostrar solo el número del host con un punto delante
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        return 'Sin IP'; // Mostrar "Sin IP" si no hay IP válida, sin warnings
                                    },
                                    'target-label': ele => {
                                        // Depuración: Mostrar datos del elemento y su nodo destino
                                        console.log(`Evaluando target-label para enlace: ${JSON.stringify(ele.data())}`);
                                        const targetId = ele.data('target');
                                        if (cy && cy.getElementById) { // Verificar que cy está inicializado
                                            const targetNode = cy.getElementById(targetId);
                                            console.log(`Nodo destino ${targetId}:`, targetNode.data());
                                            if (targetNode.length > 0) {
                                                const targetIp = targetNode.data('ip');
                                                console.log(`IP del nodo destino ${targetId}: ${targetIp} (tipo: ${typeof targetIp}, nodo: ${targetNode.id()})`);
                                                if (targetIp && targetIp !== '') { // Verificar si targetIp existe y no está vacío
                                                    return `.${getHostNumber(targetIp)}`; // Mostrar solo el número del host con un punto delante
                                                } else {
                                                    // Intentar recuperar desde router sin warnings
                                                    const routerId = targetNode.data('router');
                                                    if (routerId) {
                                                        const routerNode = cy.getElementById(routerId);
                                                        const routerInterfaces = routerNode ? routerNode.data('interfaces') : null;
                                                        if (routerInterfaces) {
                                                            const interfaceName = targetId.split('_')[1]; // Extraer el nombre de la interfaz (e.g., "eth0")
                                                            const ipFromRouter = routerInterfaces[interfaceName];
                                                            console.log(`IP encontrada en router para interfaz ${interfaceName}: ${ipFromRouter}`);
                                                            if (ipFromRouter && ipFromRouter !== '') {
                                                                return `.${getHostNumber(ipFromRouter)}`; // Mostrar solo el número del host con un punto delante
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        return 'Sin IP'; // Mostrar "Sin IP" si no hay IP válida, sin warnings
                                    },
                                    'source-text-offset': 30,
                                    'target-text-offset': 30,
                                    'source-text-margin-y': -10,
                                    'target-text-margin-y': -10,
                                    'text-rotation': 'autorotate',
                                    'font-size': 12,
                                    'color': '#00008B'
                                }
                            },
                            {
                                selector: 'edge[invisible]', // Enlaces invisibles (conexiones router-interfaz)
                                style: {
                                    'width': 1,
                                    'line-color': '#000', // Negro como solicitado
                                    'opacity': 0.2 // Visible sutilmente para influir en el layout
                                }
                            }
                        ],
                        layout: {
                            name: 'preset', // Cambiamos a 'preset' para respetar posiciones manuales
                            fit: true,
                            padding: 30 // Reducido para un ajuste más cercano
                        }
                    });

                    // Depuración: Verificar nodos AS después de inicializar Cytoscape
                    console.log("Nodos AS disponibles después de inicializar:", cy.nodes('[!parent]').map(node => ({
                        id: node.id(),
                        data: node.data(),
                        position: node.position(),
                        style: node.style()
                    })));

                    // Asegurarse de que los nodos de interfaz tengan sus IPs antes de evaluar estilos
                    cy.nodes('[type="interface"]').forEach(node => {
                        const routerId = node.data('router');
                        const interfaceName = node.id().split('_')[1]; // Extraer el nombre de la interfaz (e.g., "eth0")
                        console.log(`Verificando nodo de interfaz ${node.id()}, router: ${routerId}, interfaz: ${interfaceName}, data:`, node.data());
                        if (routerId) {
                            const routerNode = cy.getElementById(routerId);
                            console.log(`Router asociado ${routerId}:`, routerNode ? routerNode.data() : 'No encontrado');
                            if (routerNode) {
                                const routerInterfaces = routerNode.data('interfaces');
                                console.log(`Interfaces del router ${routerId}:`, routerInterfaces);
                                if (routerInterfaces && routerInterfaces[interfaceName]) {
                                    const ip = routerInterfaces[interfaceName];
                                    console.log(`Asignando IP ${ip} al nodo de interfaz ${node.id()}`);
                                    node.data('ip', ip); // Forzar la asignación de la IP al nodo de interfaz
                                } else {
                                    console.log(`No se encontraron interfaces o IP para ${interfaceName} en router ${routerId}`);
                                }
                            } else {
                                console.log(`No se encontró el router ${routerId} para nodo de interfaz ${node.id()}`);
                            }
                        }
                    });

                    // Refrescar los estilos para reflejar los cambios en data('ip') antes de evaluar etiquetas
                    cy.style().update();
                    cy.edges().trigger('style'); // Disparar evento para actualizar estilos de enlaces
                    console.log("Estilos actualizados después de forzar IPs antes de evaluar etiquetas");

                    // Refrescar el grafo para asegurar que las etiquetas se rendericen correctamente
                    cy.resize();
                    console.log("Grafo redimensionado para actualizar etiquetas");

                    // Depuración: Verificar nodos después de forzar IPs, refrescar estilos y redimensionar
                    console.log("Nodos cargados en Cytoscape después de forzar IPs, refrescar estilos y redimensionar:", cy.nodes().map(n => ({
                        id: n.id(),
                        ip: n.data('ip'),
                        label: n.data('label'),
                        type: n.data('type'),
                        position: n.position(),
                        style: n.style()
                    })));

                    // Aplicar layout 'cose' solo a nodos sin posiciones guardadas (opcional, si necesitas layout dinámico para nuevos nodos)
                    const nodesWithoutPositions = cy.nodes().filter(node => !node.position());
                    if (nodesWithoutPositions.length > 0) {
                        nodesWithoutPositions.layout({
                            name: 'cose',
                            fit: true,
                            padding: 30,
                            componentSpacing: 50,
                            nodeRepulsion: 200000,
                            idealEdgeLength: 80,
                            nodeOverlap: 10,
                            animate: true
                        }).run();
                    }

                    // Establecer un zoom inicial más cercano después de cargar
                    cy.on('layoutstop', () => {
                        cy.zoom(1.5); // Zoom inicial más cercano (ajusta este valor según necesites)
                        cy.center(); // Centrar el grafo
                    });

                    // Depuración
                    console.log("Nodos cargados en Cytoscape después del layout:", cy.nodes().map(n => ({
                        id: n.id(),
                        ip: n.data('ip'),
                        label: n.data('label'),
                        type: n.data('type'),
                        position: n.position(),
                        style: n.style()
                    })));
                    console.log("Enlaces cargados en Cytoscape:", cy.edges().map(e => ({
                        data: e.data(),
                        style: e.style()
                    })));

                    // Añadir evento de clic para toggle en los enlaces visibles
                    cy.edges('[!invisible]').on('click', evt => {
                        const edge = evt.target;
                        toggleEdgeLabel(edge);
                    });

                    // Ocultar mensaje de carga
                    document.getElementById('loading').style.display = 'none';

                    // Control de zoom
                    const zoomSlider = document.getElementById('zoom-slider');
                    zoomSlider.addEventListener('input', function() {
                        cy.zoom(parseFloat(this.value));
                        cy.center();
                    });

                    // Botón para guardar posiciones manualmente
                    document.getElementById('save-positions-btn').addEventListener('click', savePositionsManually);

                    // Modal para cambiar color de AS con doble clic
                    cy.on('dblclick', 'node[!parent]', evt => {
                        console.log('Evento de doble clic detectado, isModalClosing:', isModalClosing, 'selectedAs:', selectedAs);
                        if (isModalClosing) {
                            console.log('Doble clic ignorado, el modal está cerrándose');
                            return; // Ignorar doble clic si el modal está cerrándose
                        }

                        const node = evt.target;
                        console.log('Nodo clicado:', {
                            id: node.id(),
                            data: node.data(),
                            position: node.position(),
                            style: node.style(),
                            renderedPosition: node.renderedPosition()
                        });
                        const pos = node.renderedPosition();
                        const modal = document.getElementById('color-modal');
                        console.log('Modal DOM antes de mostrar:', {
                            id: modal.id,
                            display: window.getComputedStyle(modal).display,
                            opacity: window.getComputedStyle(modal).opacity,
                            className: modal.className,
                            offsetWidth: modal.offsetWidth,
                            offsetHeight: modal.offsetHeight,
                            zIndex: window.getComputedStyle(modal).zIndex,
                            position: window.getComputedStyle(modal).position
                        });

                        const modalWidth = modal.offsetWidth || 250; // Usar 250px si offsetWidth es 0
                        const modalHeight = modal.offsetHeight || 180; // Usar 180px si offsetHeight es 0
                        const canvasWidth = cy.width();
                        const canvasHeight = cy.height();
                        console.log('Dimensiones del canvas:', { canvasWidth, canvasHeight });

                        let left = pos.x + 10;
                        let top = pos.y - 10;
                        if (left + modalWidth > canvasWidth) left = canvasWidth - modalWidth;
                        if (top + modalHeight > canvasHeight) top = canvasHeight - modalHeight;
                        if (left < 0) left = 0;
                        if (top < 0) top = 0;

                        console.log('Posición calculada para el modal:', { left, top });

                        // Forzar la visibilidad del modal antes de la transición
                        modal.style.display = 'block';
                        modal.style.opacity = '0'; // Iniciar desde opacidad 0 para la transición
                        modal.style.left = `${left}px`;
                        modal.style.top = `${top}px`;

                        // Usar setTimeout para dar tiempo al navegador a procesar los cambios
                        setTimeout(() => {
                            modal.classList.add('show');
                            selectedAs = node.id();
                            const currentColor = node.style('background-color') || '#DDDDDD';
                            const hexColor = rgbToHex(currentColor); // Convertir a hexadecimal
                            document.getElementById('color-input').value = hexColor;
                            console.log(`Doble clic en AS ${node.id()}, color actual: ${currentColor}, convertido a: ${hexColor}, modal mostrado, isModalClosing: ${isModalClosing}, selectedAs: ${selectedAs}`);
                            console.log('Estado del modal después de mostrar:', {
                                display: window.getComputedStyle(modal).display,
                                opacity: window.getComputedStyle(modal).opacity,
                                className: modal.className,
                                offsetWidth: modal.offsetWidth,
                                offsetHeight: modal.offsetHeight,
                                zIndex: window.getComputedStyle(modal).zIndex,
                                position: window.getComputedStyle(modal).position
                            });
                        }, 0); // Retraso mínimo para permitir la actualización del DOM

                        // Asegurar que el modal se muestre incluso si la transición falla
                        if (!modal.classList.contains('show')) {
                            console.warn('El modal no se mostró automáticamente, forzando visibilidad');
                            modal.classList.add('show');
                            modal.style.opacity = '1';
                        }
                    });

                    // Tooltips para nodos
                    const popperContainer = document.getElementById('popper-container');
                    cy.nodes().forEach(node => {
                        const popperDiv = document.createElement('div');
                        popperDiv.style.position = 'absolute';
                        popperDiv.style.width = '1px';
                        popperDiv.style.height = '1px';
                        popperContainer.appendChild(popperDiv);

                        const updatePosition = () => {
                            const pos = node.renderedPosition();
                            const pan = cy.pan();
                            const zoom = cy.zoom();
                            popperDiv.style.left = `${(pos.x - pan.x) / zoom}px`;
                            popperDiv.style.top = `${(pos.y - pan.y) / zoom}px`;
                        };
                        updatePosition();

                        cy.on('pan zoom resize', updatePosition);
                        node.on('position', updatePosition);

                        let tooltipContent;
                        if (node.data('type') === 'interface') {
                            const ip = node.data('ip') || 'N/A';
                            const hostNumber = getHostNumber(ip); // Usar solo el número del host
                            tooltipContent = `Interfaz: ${node.data('label')}<br>Router: ${node.data('router')}<br>IP: ${ip} (Host: .${hostNumber})`;
                        } else {
                            tooltipContent = `ID: ${node.id()}<br>AS: ${node.data('parent') || 'N/A'}`;
                        }
                        const tip = tippy(popperDiv, {
                            content: tooltipContent,
                            theme: 'light',
                            placement: 'top',
                            trigger: 'manual',
                            maxWidth: 200
                        });

                        node.on('mouseover', () => tip.show());
                        node.on('mouseout', () => tip.hide());
                    });

                    // Tooltips para enlaces
                    cy.edges().forEach(edge => {
                        const popperDiv = document.createElement('div');
                        popperDiv.style.position = 'absolute';
                        popperDiv.style.width = '1px';
                        popperDiv.style.height = '1px';
                        popperContainer.appendChild(popperDiv);

                        const updatePosition = () => {
                            const pos = edge.renderedMidpoint();
                            const pan = cy.pan();
                            const zoom = cy.zoom();
                            popperDiv.style.left = `${(pos.x - pan.x) / zoom}px`;
                            popperDiv.style.top = `${(pos.y - pan.y) / zoom}px`;
                        };
                        updatePosition();

                        cy.on('pan zoom resize', updatePosition);
                        edge.on('position', updatePosition);

                        const sourceNode = cy.getElementById(edge.data('source'));
                        const targetNode = cy.getElementById(edge.data('target'));
                        const sourceIp = sourceNode.data('ip') || 'N/A';
                        const targetIp = targetNode.data('ip') || 'N/A';
                        const weight = edge.data('weight') || '';
                        const sourceHostNumber = getHostNumber(sourceIp); // Usar solo el número del host
                        const targetHostNumber = getHostNumber(targetIp); // Usar solo el número del host

                        const tooltipContent = edge.data('invisible') ?
                            `Conexión interna: ${sourceNode.data('router')} -> ${targetNode.data('label')}` :
                            `Subred: ${weight}<br>Origen: ${sourceNode.data('router')} (${sourceNode.data('label')}, ${sourceIp}, Host: .${sourceHostNumber})<br>Destino: ${targetNode.data('router')} (${targetNode.data('label')}, ${targetIp}, Host: .${targetHostNumber})`;

                        const tip = tippy(popperDiv, {
                            content: tooltipContent,
                            theme: 'light',
                            placement: 'top',
                            trigger: 'manual',
                            maxWidth: 200
                        });

                        edge.on('mouseover', () => tip.show());
                        edge.on('mouseout', () => tip.hide());
                    });
                } catch (error) {
                    console.error('Error al inicializar el grafo:', error);
                    alert(`Error al inicializar el mapa BGP: ${error.message}`);
                    document.getElementById('loading').textContent = 'Error al cargar el mapa. Verifica bgp_graph.json.';
                }
            })
            .catch(error => {
                console.error('Error al cargar datos:', error);
                document.getElementById('loading').textContent = `Error al cargar bgp_graph.json: ${error.message}`;
            })
            .finally(() => {
                setTimeout(() => document.getElementById('loading').style.display = 'none', 3000);
            });

        function applyColor() {
            if (selectedAs) {
                const newColor = document.getElementById('color-input').value;
                const node = cy.getElementById(selectedAs); // Usar getElementById en lugar de $id
                console.log(`Aplicando color ${newColor} al AS ${selectedAs}, nodo actual:`, {
                    data: node.data(),
                    style: node.style(),
                    renderedPosition: node.renderedPosition()
                });
                node.style('background-color', newColor);
                node.animate({
                    style: { 'border-width': 4, 'border-color': '#FF0000' }
                }, { duration: 500 }).animate({
                    style: { 'border-width': 2, 'border-color': '#000' }
                }, { duration: 500 });
                hideColorModal();
            } else {
                console.warn('No hay AS seleccionado para aplicar color.');
            }
        }

        function hideColorModal() {
            const modal = document.getElementById('color-modal');
            console.log('Iniciando cierre del modal, estado actual:', {
                isModalClosing,
                selectedAs,
                display: window.getComputedStyle(modal).display,
                opacity: window.getComputedStyle(modal).opacity,
                className: modal.className,
                offsetWidth: modal.offsetWidth,
                offsetHeight: modal.offsetHeight,
                zIndex: window.getComputedStyle(modal).zIndex,
                position: window.getComputedStyle(modal).position
            });
            isModalClosing = true; // Indicar que el modal está cerrándose
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
                modal.style.opacity = '0'; // Asegurar que la opacidad se restablezca
                isModalClosing = false; // Restablecer el flag después de cerrar
                selectedAs = null; // Restablecer selectedAs al cerrar la ventana
                console.log('Modal cerrado, estado final:', {
                    isModalClosing,
                    selectedAs,
                    display: window.getComputedStyle(modal).display,
                    opacity: window.getComputedStyle(modal).opacity,
                    className: modal.className,
                    offsetWidth: modal.offsetWidth,
                    offsetHeight: modal.offsetHeight,
                    zIndex: window.getComputedStyle(modal).zIndex,
                    position: window.getComputedStyle(modal).position
                });
            }, 300); // Animación de salida
        }
    </script>
</body>
</html>